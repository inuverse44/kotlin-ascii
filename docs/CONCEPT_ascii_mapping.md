# 概念学習: ASCIIマッピングとターミナル色表現

## 対象コード
`src/main/kotlin/com/app/rendering/AsciiMapper.kt`

## 疑問点
`coloredChar` メソッドは何をしているのか？ また、なぜ `object` でラッピングされているのか？

## 解説

### 1. `coloredChar` メソッドの3つの役割
このメソッドは、計算された「光の強さ（数値）」を「ターミナル上の視覚表現（文字列）」に変換する変換器（マッパー）です。

#### A. 文字密度による輝度表現
明るさを12段階の文字（`.,-~:;=!*#$@`）に割り当てます。
*   暗い：`.`（ドット、密度が低い）
*   明るい：`@`（アットマーク、密度が高い）
これを「ASCII Ramp」と呼び、ピクセルの輝度を文字の濃淡で表現します。

#### B. 色の動的な減衰（ディミング）
文字の形だけでなく、色そのものも明るさに応じて暗くします。
*   **工夫点**: `minColorBrightness` を導入することで、光が当たっていない影の部分でも色が完全に消えず、形状が視認できるように調整されています。

#### C. ANSI TrueColor の生成
モダンなターミナルがサポートする「24bit TrueColor」のエスケープシーケンスを生成します。
*   書式: `\u001b[38;2;R;G;Bm`
*   この文字列を文字の前に付与することで、ターミナル上でRGB指定の色が表示されます。

### 2. なぜ `object` でラッピングしているのか？
`Rotation.kt` と同様の理由で、**「ステートレスなユーティリティ（名前空間）」** として定義されています。

*   **静的な性質**: 「明るさを文字に変換する」という処理は、前回の変換結果に依存しません。
*   **名前空間の整理**: `brightnessToChar` や `coloredChar` を `AsciiMapper.xxx` と呼ぶことで、「これはASCII描画に関連する処理である」という文脈を明確にしています。
*   **効率**: レンダリングのループ内で毎秒数万回呼ばれる可能性があるため、インスタンス化のオーバーヘッドを避ける `object` (シングルトン) が適しています。

### 3. ターミナル制御の仕組み
`coloredChar` が返す文字列の構造は以下の通りです：
1.  **開始符号**: `\u001b[38;2;R;G;Bm`（ここからこの色で塗れ）
2.  **表示文字**: `$char`（この文字を表示しろ）
3.  **終了符号**: `\u001b[0m`（色の設定をリセットしろ）

## まとめ
`AsciiMapper` は、3D計算の結果（数値データ）をターミナルの制約（文字と色コード）に適合させるための **「最終出力インターフェース」** として機能しています。
数学的なロジックを一切持たず、表示に関する「翻訳」に特化しているため、他のクラスから独立したユーティリティとして設計されています。
