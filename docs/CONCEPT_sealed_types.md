# 概念学習: Sealed Interfaceと代数的データ型

## 対象コード
`src/main/kotlin/com/app/geometry/FaceColor.kt`

## 疑問点
`FaceColor` にはなぜ `sealed` 修飾子が使われているのか？（勝手に子クラスを作らせない意図は何か？）

## 解説

### 1. ドメインの厳密な定義（代数的データ型）
`sealed` は継承を制限するだけでなく、「取りうる状態を完全に把握・管理する」ために使用されます。
このコードでは、「面の塗り方」は以下の2種類**だけ**であると定義しています。
*   `Solid`（単色）
*   `Gradient`（グラデーション）

これにより、想定外の塗り方（例: `Texture`）が勝手に混入することを防ぎ、ドメインの境界を明確にしています。これは関数型プログラミングにおける **直和型 (Sum Type / Union Type)** の表現です。

### 2. `when` 式での網羅性チェック（Exhaustiveness Check）
`sealed` の最大のメリットは、分岐処理における安全性です。
コンパイラは全てのサブクラスを把握しているため、`when` 式を使用する際に `else` 分岐が不要になります。

```kotlin
// elseを書かなくてもコンパイルが通る
when (faceColor) {
    is FaceColor.Solid -> renderSolid(...)
    is FaceColor.Gradient -> renderGradient(...)
}
```

もし将来新しい色タイプを追加した場合、`sealed` であればコンパイルエラーとして修正箇所を教えてくれるため、修正漏れを防ぐことができます。

### 3. データとしての扱いやすさ
`sealed interface` と `data class` を組み合わせることで、ロジックよりも「データ構造」としての側面を強調しています。
型安全にデータをパッキングし、パターンマッチング（`when`）で取り出すという、堅牢なデータ処理フローを構築できます。

## 設計へのアドバイス
`enum` と似ていますが、`sealed` クラス/インターフェースは **「各サブクラスが異なるデータ（プロパティ）を持てる」** 点でより強力です。
（例: `Solid` は色を1つ持ち、`Gradient` は色2つと座標2つを持つ、といった構造の違いを許容できます）
