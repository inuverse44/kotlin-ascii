# 概念学習: ステートレスなユーティリティとシングルトン (`object`)

## 対象コード
`src/main/kotlin/com/app/math/Rotation.kt`

## 疑問点
`Rotation` はなぜ `class` ではなく `object` (シングルトン) として実装されているのか？

## 解説

### 1. ステートレス（状態を持たない）であるため
`Rotation` 内のメソッド（例: `rotateXY`）は、入力（ベクトルと角度）のみに基づいて出力を決定します。
「現在の回転角度」や「過去の履歴」といった内部状態（State）を保持する必要がありません。
状態を持たないため、複数のインスタンスを生成して管理する意味がなく、単一のオブジェクトで機能します。

### 2. 名前空間（Namespace）としての役割
Kotlinにおける `object` は、Javaの `static` メソッド群に近い役割を果たします。
トップレベル関数（ファイル直下に定義された関数）としても実装可能ですが、`object Rotation` で囲むことで、「回転に関連する数学処理」というグループ分け（名前空間）を明確にしています。
利用側は `Rotation.rotateXY(...)` と記述するため、コードの文脈が読み手にとって明快になります。

### 3. インスタンス化の手間を削減
`class` で定義した場合、利用するたびに `val rotator = Rotation()` のようにインスタンス化が必要です。
内部状態を持たない機能に対してインスタンス生成を行うのは冗長であり、`object` にすることでこれを回避し、即座に機能を利用可能にしています。

## 応用と一般化
数学的な操作は **「同じ入力に対しては必ず同じ出力を返す（参照透過性）」** 性質があるため、このパターンと非常に相性が良いです。

### 適しているユースケース
*   **幾何学計算 (`GeometryUtils`)**: 距離計算、交点判定など。
*   **物理演算 (`PhysicsEngine`)**: 重力、摩擦、衝突計算など。
*   **フォーマット変換 (`Converter`)**: 単位変換、座標系変換など。
*   **バリデーション (`Validator`)**: 値の整合性チェックなど。

## 設計へのアドバイス
レンダラーを自作する際は、以下の分離を意識すると柔軟な設計になります：
*   **`object`**: 純粋な計算ロジック（Math, Physics）。
*   **`class`**: 状態を持つ要素（Camera, Scene, FrameBuffer）。
